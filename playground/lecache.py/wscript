#! /usr/bin/env python
# encoding: utf-8
# Thomas Nagy, 2006-2008 (ita)

# the following two variables are used by the target "waf dist"
VERSION='0.0.1'
APPNAME='cc_test'

# these variables are mandatory ('/' are converted automatically)
srcdir = '.'
blddir = 'build'

def set_options(opt):
	#opt.tool_options('compiler_cc')
	pass

def configure(conf):
	#conf.check_tool('compiler_cc')
	conf.check_tool('gcc')

def build(bld):

	# 1. A simple program
	bld.new_task_gen(
		features = 'cc cprogram',
		source = 'main.c',
		target = 'test_c_app',
		uselib_local = 'my_static_lib',
		includes = '. /usr/include')

	# 2. A simple static lib
	bld.new_task_gen(
		features = 'cc cstaticlib',
		source = 'test_staticlib.c',
		target='my_static_lib')

	# if we had subfolder we would do the following
	#bld.add_subdirs('src')

#########################################################################################

import os, socket, asyncore
import Task

BUF = 8192
SIZE = 50
Task.net_cache = ('127.0.0.1', 51200)

def get_data(ssig, cnt, p):
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	s.connect(Task.net_cache)
	params = (ssig, str(cnt))
	s.send(','.join(params).ljust(SIZE))
	data = s.recv(SIZE)
	size = int(data.split()[0])

	#print "data received", data, "and size to read", size
	print "size to read", size

	f = open(p, 'wb')
	cnt = 0
	while cnt < size:
		data = s.recv(min(BUF, size-cnt))

		if not data:
			print  "connection ended", cnt, size
			break

		f.write(data)
		cnt += len(data)
		print len(data), cnt, size
	f.close()
	#s.close()

"""
class get_file(asyncore.dispatcher):
    def __init__(self, ssig, cnt, p):
        asyncore.dispatcher.__init__(self)
		self.ssig = ssig
		self.cnt = cnt
		self.path = p
        self.create_socket(socket.AF_INET, socket.SOCK_STREAM)
        self.connect( ('', 51200) )
		self.w = True

    def handle_connect(self):
        pass

    def handle_close(self):
        self.close()

    def handle_read(self):
		buf = 
        print self.recv(8192)

    def writable(self):
		return self.w

    def handle_write(self):
        sent = self.send(self.buffer)
        self.buffer = self.buffer[sent:]

def get_data(ssig, cnt, p):
	client = get_file(ssig, cnt, p)
	asyncore.loop()
"""

def put_data(ssig, cnt, p):
	try:
		do_put(ssig, cnt, p)
	except:
		pass

def do_put(ssig, cnt, p):
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	s.connect(Task.net_cache)
	st = os.stat(p).ST_MSIZE
	params = (ssig, str(cnt), st.st_size)
	s.send(','.join(params).ljust(SIZE))
	s.close()
	#print 'Received', repr(data)

def can_retrieve_cache(self):
	if not Task.net_cache:
		return

	self.got_cached = False
	cnt = 0
	sig = self.signature()
	ssig = sig.encode('hex')
	for node in self.outputs:
		variant = node.variant(self.env)
		p = node.abspath(self.env)
		try:
			get_data(ssig, cnt, p)
		except Exception, e:
			print e
			return

		cnt += 1

	for node in self.outputs:
		self.generator.bld.node_sigs[variant][node.id] = sig
		self.generator.bld.printout('restored %r from cache\n' % node.bldpath(self.env))

	self.got_cached = True
	return True
Task.Task.can_retrieve_cache = can_retrieve_cache

def post_run(self):
	bld = self.generator.bld
	env = self.env
	sig = self.signature()

	cnt = 0
	variant = env.variant()
	for node in self.outputs:
		try:
			os.stat(node.abspath(env))
		except OSError:
			self.has_run = MISSING
			self.err_msg = '-> missing file: %r' % node.abspath(env)
			raise Utils.WafError

		# important, store the signature for the next run
		bld.node_sigs[variant][node.id] = sig

		# We could re-create the signature of the task with the signature of the outputs
		# in practice, this means hashing the output files
		# this is unnecessary
		if Task.net_cache and not self.got_cached:
			ssig = sig.encode('hex')
			put_data(ssig, cnt, node.abspath(env))
			cnt += 1

	bld.task_sigs[self.unique_id()] = self.cache_sig
Task.Task.post_run = post_run


